<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Sectional Warping Calculator</title>
<style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    input, button { margin: 6px 0; padding: 6px; width: 300px; }
    input[type=radio] { margin: 6px 0; padding: 6px; width: 30px; }
    #results { margin-top: 20px; white-space: pre-wrap; font-family: monospace; }
</style>
</head>
<body>

<h2>Sectional Warping Calculator</h2>

<label>Ends per inch (EPI):</label><br>
<input id="epi" type="number" value="16"><br>

<label>Desired section width (inches):</label><br>
<input id="sectionWidth" type="number" value="2"><br>

<label>Desired number of sections:</label><br>
<input id="numberSections" type="number"><br>

<label>Color sequence or single color:</label><br>
<input id="colorSeq" type="text" placeholder="e.g. A8, B16, C8; or 320"><br>



<button onclick="runWarpCalc()">Calculate Sections</button>

<div id="results"></div>

<script>

    //<label>Optionally, provide a block size (will attempt to preserve blocks over section breaks)</label></br>
    //<input id="optionalBlockSize" type="number"><br>
// ----------------------------
// Grouping helper
// ----------------------------
function groupByColor(arr) {
    const groups = [];
    let current = arr[0];
    let count = 0;

    for (const c of arr) {
        if (c === current) {
            count++;
        } else {
            groups.push([current, count]);
            current = c;
            count = 1;
        }
    }
    groups.push([current, count]);
    return groups;
}
// ----------------------------
// Parse warp input 
// ----------------------------
function parseWarp(sequence) {

    try {
        // if we only get a number
        if (sequence.match(/^\d+$/)) {
            return [`A${sequence}`];
        }
        // assume we don't have a number, and instead have a list of colors + numbers 
        const regex_parse = /[a-zA-Z]+\d+/g;
        return sequence.match(regex_parse);
    }
    catch (error) {
        document.getElementById("results").textContent = "Bad warp sequence input: please re-try";
        return [];
    }
}

// ----------------------------
// Main calculation
// ----------------------------
function runWarpCalc() {
    const sectionWidth = Number(document.getElementById("sectionWidth").value);
    const epi = Number(document.getElementById("epi").value);   // user‑entered EPI
    const numberSections = Number(document.getElementById("numberSections").value);
    //const blockSize = document.getElementById("numberSections").value ? Number(document.getElementById("optionalBlockSize").value): 0;

    const seq = document.getElementById("colorSeq").value.trim();
    const inputSeq = parseWarp(seq);

    let totalEnds = 0;
    let warpColorSequence = [];

    // Build full warp sequence
    for (const stripe of inputSeq) {
        const ends = parseInt(stripe.match(/\d+/)[0], 10);
        const color = stripe.match(/[a-zA-Z]+/)[0];

        totalEnds += ends;
        for (let i = 0; i < ends; i++) {
            warpColorSequence.push(color);
        }
    }

    const widthInReed = totalEnds / epi; 

    // Minimum ends per section based on user EPI
    const minEndsPerSection = Math.floor(epi * sectionWidth);

    // Ends per section (initial distribution)
    const approximate = Math.floor(totalEnds / numberSections);
    let modulo = totalEnds % numberSections;

    let sectionEnds = Array(numberSections).fill(approximate);

    // Distribute extra ends from outside to inside, two at a time 
    // once we reach the center, reset to outside 
    if (modulo !== 0) {
        let left = 0;
        let right = sectionEnds.length - 1;
        const halfway = sectionEnds.length / 2;

        while (modulo > 0) {
            sectionEnds[left] += 1;
            sectionEnds[right] += 1;
            left++;
            right--;
            modulo -= 2;

            if (left > halfway) left = 0;
            if (right < halfway) right = sectionEnds.length - 1;

            if (modulo === 1) {
                sectionEnds[left] += 1;
                modulo -= 1;
            }
        }
    }

    let results = "";

    // Show user‑entered values for clarity and ease of copy/paste 
    results += `Project EPI: ${epi}\n`;
    results += `Total warp ends: ${totalEnds}\n`;
    results += `Project width in reed: ${widthInReed.toFixed(3)} inches\n`;
    results += `Project section width: ${sectionWidth} inches\n`;
    results += `Number of sections: ${numberSections}\n`; 
    results += `Minimum ends per section: ${minEndsPerSection} ends\n\n`;

    let start = 0;

    // warn if number of sections * EPI is less than color sequence value 
    if (totalEnds < epi * sectionWidth * numberSections) { 
        results += `⚠️ WARNING: fewer ends than required (${epi} EPI * ${numberSections} sections * ${sectionWidth} inch sections > ${totalEnds} total ends)\n\n`;
    }

    // Slice into sections
    for (let i = 0; i < numberSections; i++) {
        const length = sectionEnds[i];
        const selected = warpColorSequence.slice(start, start + length);
        const grouped = groupByColor(selected);

        results += `Section ${i + 1}`;

        //  Warning if section is too thin
        if (selected.length < minEndsPerSection) {
            results += `  ⚠️ WARNING: fewer ends than required (${selected.length} < ${minEndsPerSection})\n`;
        }

        if (selected.length > minEndsPerSection * 1.5) {
            results += `  ⚠️ WARNING: more ends than recommended (${selected.length} < 150% of ${minEndsPerSection})\n`;
        }

        if (inputSeq.length > 1) {
            results += ` (${selected.length} ends):  `;

            for (const [color, count] of grouped) {
                results += `\n  ${color}: ${count}  `;
            }
            results += `\n\n`;
        }
        else {
            results += `${selected.length} ends  \n`;
        }

        start += length;
    }

    document.getElementById("results").textContent = results;
}

    
</script>


</body>
</html>
